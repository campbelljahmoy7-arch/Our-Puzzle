<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>100-Piece Jigsaw Puzzle</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#0f2a3d;
      --card: rgba(255,255,255,.08);
      --text: #e9f2ff;
      --muted: rgba(233,242,255,.72);
      --accent: #7dd3fc;
      --good: #86efac;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      color:var(--text);
      background: radial-gradient(1000px 700px at 20% 15%, rgba(125,211,252,.22), transparent 55%),
                  radial-gradient(900px 600px at 80% 0%, rgba(134,239,172,.14), transparent 50%),
                  linear-gradient(135deg, var(--bg1), var(--bg2));
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    header{
      padding:18px 16px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{display:flex; flex-direction:column; gap:2px;}
    .brand h1{font-size:18px; margin:0; letter-spacing:.2px;}
    .brand p{margin:0; font-size:13px; color:var(--muted);}

    .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}
    .pill{
      background: var(--card);
      border: 1px solid rgba(255,255,255,.12);
      padding:10px 12px;
      border-radius:999px;
      display:flex;
      align-items:center;
      gap:8px;
      box-shadow: 0 10px 25px rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
    }
    .pill b{font-size:13px}
    .pill span{font-size:13px; color:var(--muted)}

    .btn{
      cursor:pointer;
      border:none;
      background: rgba(125,211,252,.18);
      color: var(--text);
      border: 1px solid rgba(125,211,252,.35);
      padding:10px 12px;
      border-radius:999px;
      font-weight:600;
      font-size:13px;
      transition: transform .08s ease, background .15s ease;
    }
    .btn:hover{ background: rgba(125,211,252,.26); }
    .btn:active{ transform: scale(.98); }
    .btn.secondary{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.15);
    }
    .btn.secondary:hover{ background: rgba(255,255,255,.12); }

    main{
      flex:1;
      padding: 0 16px 18px;
      display:flex;
      gap:14px;
      align-items:stretch;
      justify-content:center;
    }
    .panel{
      background: var(--card);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 70vh;
    }
    .panelHead{
      padding:12px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .panelHead h2{font-size:14px; margin:0; letter-spacing:.2px;}
    .panelHead small{color: var(--muted);}

    .pilePanel{ width: min(420px, 32vw); }
    .boardPanel{ flex:1; min-width: 320px; }

    @media (max-width: 920px){
      main{ flex-direction:column; }
      .pilePanel{ width: 100%; min-height: 260px; }
      .boardPanel{ width: 100%; }
    }

    .pile{
      position:relative;
      flex:1;
      padding:12px;
      overflow:hidden;
    }
    .pileHint{
      font-size:12px;
      color: var(--muted);
      padding: 10px 12px 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.08);
    }

    .boardWrap{
      position:relative;
      flex:1;
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .board{
      position:relative;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 18px 55px rgba(0,0,0,.25);
      overflow:hidden;
      touch-action:none;
    }
    .gridOverlay{
      position:absolute; inset:0;
      pointer-events:none;
      opacity:.45;
      background-image:
        linear-gradient(to right, rgba(255,255,255,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.08) 1px, transparent 1px);
      background-size: var(--tileW) var(--tileH);
    }

    .piece{
      position:absolute;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      background-repeat:no-repeat;
      background-size: var(--boardW) var(--boardH);
      cursor: grab;
      user-select:none;
      touch-action:none;
      will-change: left, top;
    }
    .piece:active{ cursor: grabbing; }
    .piece.locked{
      border-color: rgba(134,239,172,.55);
      cursor: default;
    }

    .modal{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      padding: 18px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width: min(520px, 96vw);
      border-radius: 20px;
      background: rgba(15,25,40,.92);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 25px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      padding: 16px;
    }
    .modalCard h3{ margin:0 0 8px; font-size:18px; }
    .modalCard p{ margin:0 0 12px; color:var(--muted); line-height:1.45; }
    .modalRow{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      display:none;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
    }
    .toast.show{ display:block; }
  </style>
</head>

<body>
  <header>
    <div class="brand">
      <h1>100-Piece Jigsaw Puzzle</h1>
      <p>10 √ó 10 (ideal square grid). Drag pieces onto the board and they snap into place.</p>
    </div>

    <div class="hud">
      <div class="pill"><b>Pieces</b> <span><span id="doneCount">0</span>/100</span></div>
      <div class="pill"><b>Time</b> <span id="time">00:00</span></div>
      <button class="btn secondary" id="toggleGuide">Toggle Grid</button>
      <button class="btn secondary" id="togglePreview">Preview</button>
      <button class="btn" id="shuffle">Shuffle</button>
    </div>
  </header>

  <main>
    <section class="panel pilePanel">
      <div class="panelHead">
        <h2>Piece Pile</h2>
        <small>drag pieces out</small>
      </div>
      <div class="pile" id="pile"></div>
      <div class="pileHint">
        Tip: If pieces feel ‚Äútoo snappy,‚Äù I can reduce the snap distance. If they feel hard to place, I can increase it.
      </div>
    </section>

    <section class="panel boardPanel">
      <div class="panelHead">
        <h2>Board</h2>
        <small>10 √ó 10 grid</small>
      </div>
      <div class="boardWrap">
        <div class="board" id="board">
          <div class="gridOverlay" id="gridOverlay"></div>
        </div>
      </div>
    </section>
  </main>

  <div class="modal" id="modal">
    <div class="modalCard">
      <h3 id="modalTitle">Preview</h3>
      <p id="modalText">Full image preview (close to continue).</p>
      <div id="previewBox" style="display:block; margin: 10px 0 14px; border-radius: 14px; overflow:hidden; border:1px solid rgba(255,255,255,.12);"></div>
      <div class="modalRow">
        <button class="btn secondary" id="closeModal">Close</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const IMAGE_URL = "./puzzle.jpg";

    // Ideal 100-piece grid
    const COLS = 10;
    const ROWS = 10;
    const TOTAL = COLS * ROWS;

    // Snap distance = min(tileW, tileH) * factor
    const SNAP_FACTOR = 0.23;
    const PILE_PADDING = 10;

    const pileEl = document.getElementById("pile");
    const boardEl = document.getElementById("board");
    const gridOverlayEl = document.getElementById("gridOverlay");
    const doneCountEl = document.getElementById("doneCount");
    const timeEl = document.getElementById("time");
    const toastEl = document.getElementById("toast");

    const modalEl = document.getElementById("modal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalTextEl = document.getElementById("modalText");
    const previewBoxEl = document.getElementById("previewBox");

    const shuffleBtn = document.getElementById("shuffle");
    const togglePreviewBtn = document.getElementById("togglePreview");
    const closeModalBtn = document.getElementById("closeModal");
    const toggleGuideBtn = document.getElementById("toggleGuide");

    const img = new Image();
    img.src = IMAGE_URL;

    let boardW = 0, boardH = 0;
    let tileW = 0, tileH = 0;
    let snapDist = 0;

    let pieces = [];
    let doneCount = 0;
    let zTop = 10;

    let startTime = null;
    let timerRAF = null;

    function pad2(n){ return String(n).padStart(2,"0"); }
    function startTimer(){
      if(startTime) return;
      startTime = performance.now();
      const tick = () => {
        const ms = performance.now() - startTime;
        const totalSec = Math.floor(ms/1000);
        const m = Math.floor(totalSec/60);
        const s = totalSec % 60;
        timeEl.textContent = `${pad2(m)}:${pad2(s)}`;
        timerRAF = requestAnimationFrame(tick);
      };
      tick();
    }
    function stopTimer(){
      if(timerRAF) cancelAnimationFrame(timerRAF);
      timerRAF = null;
    }

    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>toastEl.classList.remove("show"), 1600);
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function rand(min, max){ return Math.random() * (max - min) + min; }

    function setPiecePos(piece, x, y, containerEl){
      piece.el.style.left = x + "px";
      piece.el.style.top  = y + "px";
      if(piece.el.parentElement !== containerEl){
        containerEl.appendChild(piece.el);
      }
    }

    function getRelativePos(e, container){
      const rect = container.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function computeBoardSize(){
      const wrap = boardEl.parentElement;
      const maxW = wrap.clientWidth - 24;
      const maxH = wrap.clientHeight - 24;

      const aspect = img.naturalWidth / img.naturalHeight;

      let w = maxW;
      let h = w / aspect;
      if(h > maxH){
        h = maxH;
        w = h * aspect;
      }
      w = Math.max(320, w);
      h = w / aspect;

      boardW = Math.floor(w);
      boardH = Math.floor(h);

      tileW = boardW / COLS;
      tileH = boardH / ROWS;

      snapDist = Math.min(tileW, tileH) * SNAP_FACTOR;

      boardEl.style.width = boardW + "px";
      boardEl.style.height = boardH + "px";

      boardEl.style.setProperty("--boardW", boardW + "px");
      boardEl.style.setProperty("--boardH", boardH + "px");
      boardEl.style.setProperty("--tileW", tileW + "px");
      boardEl.style.setProperty("--tileH", tileH + "px");

      gridOverlayEl.style.backgroundSize = `${tileW}px ${tileH}px`;

      for(const p of pieces){
        p.correctX = p.col * tileW;
        p.correctY = p.row * tileH;
        p.el.style.width = tileW + "px";
        p.el.style.height = tileH + "px";
        p.el.style.backgroundSize = `${boardW}px ${boardH}px`;
        p.el.style.backgroundPosition = `${-p.correctX}px ${-p.correctY}px`;
        if(p.locked) setPiecePos(p, p.correctX, p.correctY, boardEl);
      }
    }

    function clearGame(){
      pieces = [];
      doneCount = 0;
      doneCountEl.textContent = "0";
      pileEl.innerHTML = "";
      [...boardEl.querySelectorAll(".piece")].forEach(n => n.remove());
      startTime = null;
      timeEl.textContent = "00:00";
      stopTimer();
    }

    function attachDrag(piece){
      const el = piece.el;

      el.addEventListener("pointerdown", (e) => {
        if(piece.locked) return;

        startTimer();

        piece.dragging = true;
        piece.pointerId = e.pointerId;

        el.setPointerCapture(e.pointerId);
        el.style.zIndex = (++zTop).toString();

        const container = el.parentElement;
        const pos = getRelativePos(e, container);

        const left = parseFloat(el.style.left) || 0;
        const top  = parseFloat(el.style.top) || 0;

        piece.offsetX = pos.x - left;
        piece.offsetY = pos.y - top;
      });

      el.addEventListener("pointermove", (e) => {
        if(!piece.dragging || piece.pointerId !== e.pointerId) return;

        const container = el.parentElement;
        const pos = getRelativePos(e, container);

        let x = pos.x - piece.offsetX;
        let y = pos.y - piece.offsetY;

        const maxX = container.clientWidth - tileW;
        const maxY = container.clientHeight - tileH;
        x = clamp(x, 0, Math.max(0, maxX));
        y = clamp(y, 0, Math.max(0, maxY));

        el.style.left = x + "px";
        el.style.top  = y + "px";
      });

      el.addEventListener("pointerup", (e) => finishDrag(piece, e));
      el.addEventListener("pointercancel", (e) => finishDrag(piece, e));
    }

    function finishDrag(piece, e){
      if(!piece.dragging || piece.pointerId !== e.pointerId) return;

      piece.dragging = false;
      piece.pointerId = null;

      const boardRect = boardEl.getBoundingClientRect();
      const inBoard =
        e.clientX >= boardRect.left &&
        e.clientX <= boardRect.right &&
        e.clientY >= boardRect.top &&
        e.clientY <= boardRect.bottom;

      if(inBoard){
        const posBoard = getRelativePos(e, boardEl);
        const x = posBoard.x - piece.offsetX;
        const y = posBoard.y - piece.offsetY;

        setPiecePos(piece, x, y, boardEl);
        maybeSnap(piece);
      }
    }

    function maybeSnap(piece){
      if(piece.el.parentElement !== boardEl) return;

      const x = parseFloat(piece.el.style.left) || 0;
      const y = parseFloat(piece.el.style.top) || 0;

      const dx = x - piece.correctX;
      const dy = y - piece.correctY;

      if(Math.hypot(dx, dy) <= snapDist){
        setPiecePos(piece, piece.correctX, piece.correctY, boardEl);
        piece.locked = true;
        piece.el.classList.add("locked");
        piece.el.style.zIndex = "1";

        doneCount++;
        doneCountEl.textContent = String(doneCount);

        if(doneCount % 10 === 0) toast(`Nice! ${doneCount}/100`);
        if(doneCount === TOTAL){
          stopTimer();
          openModal("You finished! üéâ", `100/100 pieces completed in ${timeEl.textContent}.`, true);
        }
      }
    }

    function buildPieces(){
      clearGame();
      computeBoardSize();

      const pileW = pileEl.clientWidth;
      const pileH = pileEl.clientHeight;

      for(let row=0; row<ROWS; row++){
        for(let col=0; col<COLS; col++){
          const el = document.createElement("div");
          el.className = "piece";

          const correctX = col * tileW;
          const correctY = row * tileH;

          el.style.width = tileW + "px";
          el.style.height = tileH + "px";
          el.style.backgroundImage = `url("${IMAGE_URL}")`;
          el.style.backgroundSize = `${boardW}px ${boardH}px`;
          el.style.backgroundPosition = `${-correctX}px ${-correctY}px`;

          const maxX = Math.max(PILE_PADDING, pileW - tileW - PILE_PADDING);
          const maxY = Math.max(PILE_PADDING, pileH - tileH - PILE_PADDING);
          const x = rand(PILE_PADDING, maxX);
          const y = rand(PILE_PADDING, maxY);

          pileEl.appendChild(el);
          el.style.left = x + "px";
          el.style.top  = y + "px";

          const piece = {
            el, col, row,
            correctX, correctY,
            locked:false,
            dragging:false,
            pointerId:null,
            offsetX:0, offsetY:0
          };

          attachDrag(piece);
          pieces.push(piece);
        }
      }
      toast("Pieces created: 100");
    }

    function shufflePieces(){
      const pileW = pileEl.clientWidth;
      const pileH = pileEl.clientHeight;
      let moved = 0;

      for(const p of pieces){
        if(p.locked) continue;

        const maxX = Math.max(PILE_PADDING, pileW - tileW - PILE_PADDING);
        const maxY = Math.max(PILE_PADDING, pileH - tileH - PILE_PADDING);
        const x = rand(PILE_PADDING, maxX);
        const y = rand(PILE_PADDING, maxY);

        pileEl.appendChild(p.el);
        p.el.style.left = x + "px";
        p.el.style.top  = y + "px";
        p.el.style.zIndex = (++zTop).toString();
        moved++;
      }
      toast(`Shuffled ${moved} pieces`);
    }

    function openModal(title, text, showPreview){
      modalTitleEl.textContent = title;
      modalTextEl.textContent = text;

      previewBoxEl.innerHTML = "";
      if(showPreview){
        const im = document.createElement("img");
        im.src = IMAGE_URL;
        im.alt = "Puzzle preview";
        im.style.width = "100%";
        im.style.display = "block";
        previewBoxEl.appendChild(im);
      }
      modalEl.classList.add("show");
    }
    function closeModal(){ modalEl.classList.remove("show"); }

    shuffleBtn.addEventListener("click", shufflePieces);
    togglePreviewBtn.addEventListener("click", () => openModal("Preview", "Full image preview (close to continue).", true));
    closeModalBtn.addEventListener("click", closeModal);
    modalEl.addEventListener("click", (e) => { if(e.target === modalEl) closeModal(); });

    let gridOn = true;
    toggleGuideBtn.addEventListener("click", () => {
      gridOn = !gridOn;
      gridOverlayEl.style.display = gridOn ? "block" : "none";
      toast(gridOn ? "Grid on" : "Grid off");
    });

    window.addEventListener("resize", () => computeBoardSize());

    img.onload = () => {
      buildPieces();
      shufflePieces();

      // preload preview image
      const im = document.createElement("img");
      im.src = IMAGE_URL;
      im.alt = "Puzzle preview";
      im.style.width = "100%";
      im.style.display = "block";
      previewBoxEl.appendChild(im);
    };

    img.onerror = () => {
      openModal(
        "Error",
        "Could not load puzzle.jpg. Make sure it is named exactly 'puzzle.jpg' and is in the same folder as index.html.",
        false
      );
    };
  </script>
</body>
</html>
